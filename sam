#!/bin/bash

#set -vx
SAM_VERSION='1.11';

#Configuring
BIN_DIR=${BIN_DIR:-/opt/bin}
SAM_DB_SQLITE=${SAM_DB_SQLITE:-/var/db/sam/smilart.db}
SAM_HISTORY=${SAM_HISTORY:-/var/db/sam/history}

## Functions
# Copy META from image
# copy_meta_func <DockerId>
copy_meta_func() {
        local file

        TEMPLATE_DIR=`mktemp -d`;
        docker run -i -t --rm -v $TEMPLATE_DIR:$TEMPLATE_DIR  --net=host --entrypoint="cp" $1 -r /meta $TEMPLATE_DIR/meta 2>&1 > /dev/null;
        if [[ $? -ne 0 ]]; then
                echo -e "\E[31mERROR: Directory '/meta' not found in image.">&2;tput sgr0;
                rm -rf $TEMPLATE_DIR;
                if [ -n `sqlite3 $SAM_DB_SQLITE "select ImageName from $SAM_DB_TABLE_INSTALL_APPS where DockerId=$1"` ] ; then
                    read -r -p "Remove the app from sam repository? [y/N] " response
                    case $response in
                        [yY][eE][sS]|[yY])
                          delete_app_to_db_func $1;
                          exit 0
                          ;;
                        *)
                          exit 0
                          ;;
                    esac
                else
                    exit 1;
                fi;
        fi;
        # Remove files *.expand
        for file in $(find $TEMPLATE_DIR/meta -type f -name "*.expand"); do
           rm -f $file;
        done
}

# Uninstall apps function
# uninstall_app_func <DockerId>
uninstall_app_func() {
        copy_meta_func $1;
        pwd=$PWD;
        cd $TEMPLATE_DIR/meta;
        source $TEMPLATE_DIR/meta/uninstall;
        cd $pwd;
        rm -rf $TEMPLATE_DIR;
        echo;
        unset TEMPLATE_DIR;
}

# Install apps function
# install_app_func <DockerId>
install_app_func() {
        copy_meta_func $1;
        pwd=$PWD;
        cd $TEMPLATE_DIR/meta;
        echo;
        source $TEMPLATE_DIR/meta/install;
        cd $pwd;
        rm -rf $TEMPLATE_DIR;
        echo;
        unset TEMPLATE_DIR;
}

# create_tag_app <DockerId> <app>:<version>
create_tag_app(){
        SAM_APP_LABEL=`docker inspect $1 | grep -m 1 com.smilart.repo_base_name | awk -F '"'  '{print $4}'`
        if [[ -n $SAM_APP_LABEL ]];then
                echo;
                echo -e "\E[32mCreating tag '$SAM_APP_LABEL/$2' from app";tput sgr0
                docker tag $1 $SAM_APP_LABEL/$2;
                if [[ $? -ne 0 ]]; then
                    echo -e "\E[31mERROR: Not created app tag.">&2;tput sgr0;
                    exit 1;
                fi;
        else
                echo;
                echo "Not found Label for app.";
        fi;
}
# Delete apps in db function
# delete_app_to_db_func <DockerId>;
delete_app_to_db_func() {
        echo  "Deleting app in db.";
        sqlite3 $SAM_DB_SQLITE "delete from $SAM_DB_TABLE_INSTALL_APPS where DockerId='$1'";
}

create_connect_func() {
        echo "Add 'connect' command in the system.";
        echo '#!/bin/bash 

connect_func(){
PID=`/usr/bin/docker inspect --format {{.State.Pid}} $1`;
if [ -z $PID ]; then
        echo -e "\E[31mContainer $1 is not found."; tput sgr0;
else
        if [ $PID -eq 0 ]; then
                echo -e "\E[31mContainer $1 is not started.";tput sgr0;
        else
                echo -e "\E[32mConnect to container $1."; tput sgr0;
                /usr/bin/docker exec -i -t $1 /bin/bash -c "cd /root ; TERM=xterm HOME=/root /bin/bash";
        fi;
fi;
}

connect_func $@;' > $BIN_DIR/connect;
        chmod +x $BIN_DIR/connect;
        if [[ -z `id smilart 2>&1 | grep 'no such user'` ]]; then
             chown smilart $BIN_DIR/connect;
        fi;
}

# save_app_in_db <DockerId> <ImageName> <ImageVersion> <ImageRepos NUMBER>
save_app_in_db(){
    echo  "Save app to db.";
    sqlite3 $SAM_DB_SQLITE "insert into $SAM_DB_TABLE_INSTALL_APPS (DockerId,ImageName,ImageVersion,ImageRepos) values ('$1','$2','$3','$4');";
}

# check_app_in_db <DockerId> <ImageName> <ImageVersion>
#if app exist or not found label com.smilart.multiple_versions="supported" then error
check_app_in_db(){
    if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$2' AND ImageVersion='$3'"` ]];then
        echo -e "\E[31mERROR: Apps $2:$3 exist in db.">&2;tput sgr0;
        exit 1;
    fi;
    if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$2'"` ]];then
        if [[ "supported" != "`docker inspect $1 | grep -m 1 com.smilart.multiple_versions | awk -F '"'  '{print $4}'`" ]];then
            echo -e "\E[31mERROR: Apps with name \"$2\" exist in db.">&2;tput sgr0;
            exit 1;
        fi;
    fi;
}

## Testing
#
if [[ ! -d /var/db/sam ]];then
        mkdir -p '/var/db/sam';
fi;

if [[ -z `which docker` ]]; then
        echo -e "\E[31mERROR: Not found command 'docker' in system.">&2;tput sgr0;
        exit 1;
fi;

# This root?
if [[ $EUID -ne 0 ]]; then
        echo -e "\E[31mThis script must be run as root">&2;tput sgr0;
        exit 1;
fi

# Exist BIN_DIR dirrectory ?
if ! [[ -d $BIN_DIR ]]; then
        echo "Creating $BIN_DIR.";
        mkdir -p $BIN_DIR;
fi

# Exist BIN_DIR in path ?
if [[ -z `echo $PATH | grep $BIN_DIR` ]]; then
        echo -e "\E[31mERROR: Not found path \"$BIN_DIR\" in environments \$PATH. Add.">&2;tput sgr0;
        exit 1;
fi;

# Exist command 'connect'?
if ! [[ -f $BIN_DIR/connect ]]; then
        create_connect_func;
        echo;
fi;

# Exist command sqlite3
if [[ -z `which sqlite3` ]]; then
        echo -e "\E[31mERROR: Not found command 'sqlite3' in system.">&2;tput sgr0;
        exit 1;
fi;

# Exist dbs?
SAM_DB_TABLE_INSTALL_APPS="Apps";
if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT name FROM sqlite_master WHERE type='table' AND name='$SAM_DB_TABLE_INSTALL_APPS'"` ]];then
        echo;
        echo "Creating table $SAM_DB_TABLE_INSTALL_APPS.";
        echo;
        sqlite3 $SAM_DB_SQLITE "create table $SAM_DB_TABLE_INSTALL_APPS (id INTEGER PRIMARY KEY,DockerId TEXT,ImageName TEXT,ImageVersion TEXT,ImageRepos INTEGER);";
fi;

SAM_DB_TABLE_REPOS="Repos";
SAM_DB_TABLE_REPOS_URL="smilart";
if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT name FROM sqlite_master WHERE type='table' AND name='$SAM_DB_TABLE_REPOS'"` ]];then
        echo;
        echo "Creating table $SAM_DB_TABLE_REPOS.";
        echo;
        sqlite3  $SAM_DB_SQLITE "create table $SAM_DB_TABLE_REPOS (id INTEGER PRIMARY KEY,ReposFlag TEXT,ReposName TEXT,ReposUrl, TEXT, ReposUser TEXT, ReposPass TEXT, ReposEmail TEXT);";
        echo "Adding default repository: $SAM_DB_TABLE_REPOS_URL";
        echo;
        sqlite3 $SAM_DB_SQLITE "insert into $SAM_DB_TABLE_REPOS (ReposFlag,ReposName,ReposUrl,ReposUser,ReposPass,ReposEmail) values ('*','official','$SAM_DB_TABLE_REPOS_URL','','','');";
fi;
unset SAM_DB_TABLE_REPOS_URL;

## Help section
USAGE="
  Usage:
        sam [--global-options] <command> [--command-options] [arguments]

  Global Options:
        --help, -h              Help.
        --debug, -x             Debug mode.


  Commands:
        help                    Print help.

     Software Management:
        install, in             Install applications.
        remove, rm              Remove applications.
        list                    List installed applications.
        search, se              Search image version on private registry.
        info                    Print application info.
        upgrade, up             Upgrade Smilart Os.

     Repository Management:
        addrepo, ar             Add a new repository.
        removerepo, rr          Remove specified repository.
        modifyrepo, mr          Modify specified repository.
        listrepos, lr           List all defined repositories.

  Version SAM v$SAM_VERSION

";

USAGE_INSTALL="
install (in) <app>:<version>
install (in) <filename>

Install smilart applications with specified capabilities from repository and from gzip or tar archive.

";

USAGE_UPGRADE="
upgrade (up) <url>

Update Core OS with the update engine client.

";

USAGE_REMOVE="
remove (rm) <app>[:<version>]

Remove smilart applications with specified capabilities.

";

USAGE_SEARCH="
search (se) [image name]

Search version docker images from private docker-registry.
WARN: Search does not work on official Docker Hub.

";

USAGE_LIST="
list [options]

List all install smilart applications.

  Command options:
    --raw                       List all install smilart applications in RAW format.

";

USAGE_INFO="
info <name>

Print application info.

";

USAGE_ADDREPO="
addrepo (ar) [--default] [--name <name>] [--server <hostname>] [--username <username>] [--password <password>] [--email <email>]

Add a repository to the system.

  Command options:
    --default                   Add the repository as default.
    --name                      Add a descriptive name for the repository.
    --server                    Add a hostname to server docker-registry.
    --username                  Optional. Add the user name for authentication.
    --password                  Optional. Add the password for authentication.
    --email                     Optional. Add the email for authentication.

";

USAGE_REMOVEREPO="
removerepo (rr) <id|name>

Remove repository specified by name or number.

";

USAGE_PURGE="
purge

Run removing old images from the system.

";

USAGE_MODIFYREPO="
modifyrepo (mr) <id> [--default] [--name <name>] [--server <hostname>] [--username <username>] [--password <password>] [--email <email>]

Modify properties of repositories specified.

  Command options:
-d  --default                   Set priority of the repository.
    --name                      Set a descriptive name for the repository.
    --server                    Set a server name to docker-registry.
    --username                  Set the user name for authentication to the server.
    --password                  Set the password for authentication to the server.
    --email                     Set the email for authentication to the server. 

";

USAGE_LISTREPOS="
listrepos (lr) [options]

List all defined repositories.
    --raw                       List all defined repositories in RAW format.
";

## Function for case
install_func(){
    local SAM_INSTALL_DOCKER_ID;
    local SAM_INSTALL_REPO_ID;
    local SAM_INSTALL_VERSION;
    local SAM_INSTALL_APP;
    local SAM_INSTALL_REPOS_URL;
    local SAM_INSTALL_REPOS_NAME;
    local SAM_INSTALL_USER;
    local SAM_INSTALL_PASSWORD;
    local SAM_INSTALL_EMAIL;
    local SAM_INSTALL_COMMAND_OPTIONS;
    local SAM_PREFIX_IMAGE_DOCKER;

    local CHECK_APP_IN_FILE

    if [ -f "$1" ];then
        # Find file "repositories"
        CHECK_APP_IN_FILE="`tar -xOf $1 repositories 2>&1`";
        if [[ $? -ne 0 ]]; then
            echo -e "\E[31mERROR: File repositories not found in archive.">&2;tput sgr0;
            exit 1;
        fi;
        if [[ -z "$CHECK_APP_IN_FILE" ]]; then
            echo -e "\E[31mERROR: Incorrectly created archive. File repositories is bad.">&2;tput sgr0;
            exit 1;
        fi;
        SAM_PREFIX_IMAGE_DOCKER=`echo "$CHECK_APP_IN_FILE" | awk -F '"' ' {print $2} ' | sed "s/ /:/g" | awk -F '/' '{print $1}'`;
        SAM_INSTALL_APP=`echo "$CHECK_APP_IN_FILE" | awk -F '"' ' {print $2} ' | sed "s/ /:/g" | awk -F '/' '{print $NF}'`;
        SAM_INSTALL_VERSION=`echo "$CHECK_APP_IN_FILE" | awk -F '"' ' {print $4} ' | sed "s/ /:/g"`;
        if [[ -z $SAM_PREFIX_IMAGE_DOCKER ]] || [[ -z $SAM_INSTALL_VERSION ]]; then
            echo -e "\E[31mERROR: Incorrect file 'repositories' in archive.">&2;tput sgr0;
            echo "Not found application name or version in file.";
            echo "May be incorrectly created archive.";
            exit 1;
        fi;
	
        echo "Loading image '$SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION'.";
        docker load -i $1;
        if [[ $? -ne 0 ]]; then
            echo -e "\E[31mERROR: Loading image.">&2;tput sgr0;
            exit 1;
        fi;

        SAM_INSTALL_DOCKER_ID=`docker images | grep -v 'REPOSITORY' | awk -F ' ' ' {print $1,$2,$3} ' | sed "s/ /:/g" | grep "$SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION:" | awk -F ':' '{print $NF}'`;
	
        SAM_INSTALL_REPO_ID=0;
    else

        # if $1 in docker repo
        SAM_INSTALL_VERSION=`echo "$1" | awk -F '/' '{print $NF}' | awk -F ':' '{print $2}'`;
        if [[ -z $SAM_INSTALL_VERSION ]];then
            echo -e "\E[31mERROR: Version in string '$1' is not found.">&2;tput sgr0;
            exit 1;
        fi;
        SAM_INSTALL_APP=`echo "$1" | awk -F '/' '{print $NF}' | awk -F ':' '{print $1}'`;
        SAM_INSTALL_REPOS_NAME=`echo "$1" | sed "s#\$SAM_INSTALL_APP\:\$SAM_INSTALL_VERSION##g" | sed 's/\/$//'`;
        if [[ -z $SAM_INSTALL_REPOS_NAME ]];then
            SAM_INSTALL_REPOS_NAME=`sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposFlag='*'" | sed 's/\/$//' | awk -F '/' '{print $NF}'`;
        fi;
        #Exist repository in db?
        if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"` ]];then
            echo -e "\E[31mERROR: Not found name repository '$SAM_INSTALL_REPOS_NAME' in db.">&2;tput sgr0;
            exit 1;
        fi;
        #logging
        SAM_INSTALL_USER=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUser from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'" | sed 's/[\ \t]//g'`;
        SAM_PREFIX_IMAGE_DOCKER=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'" | sed 's/\/$//' | awk -F '/' '{print $NF}'`;
        if [[ -n $SAM_INSTALL_USER ]];then
            SAM_INSTALL_PASSWORD=`sqlite3 $SAM_DB_SQLITE "SELECT ReposPass from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"`;
            SAM_INSTALL_EMAIL=`sqlite3 $SAM_DB_SQLITE "SELECT ReposEmail from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"`;
            SAM_INSTALL_REPOS_URL=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"`;
            if [ -n "$SAM_INSTALL_EMAIL" ];then
                SAM_INSTALL_COMMAND_OPTIONS="--email=$SAM_INSTALL_EMAIL";
            else
                SAM_INSTALL_COMMAND_OPTIONS='--email=none';
            fi;
            docker login --username=$SAM_INSTALL_USER --password=`echo "$SAM_INSTALL_PASSWORD" | base64 -d` $SAM_INSTALL_COMMAND_OPTIONS $SAM_PREFIX_IMAGE_DOCKER 2>&1 > /dev/null;
            if [[ $? -ne 0 ]]; then
                echo -e "\E[31mERROR: Wrong login/password or url from repository.">&2;tput sgr0;
            fi;
        fi;
        SAM_INSTALL_REPO_ID=`sqlite3 $SAM_DB_SQLITE "SELECT Id FROM $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"`;
        docker pull $SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION;
        if [[ $? -ne 0 ]]; then
            echo -e "\E[31mERROR: Not download smilart applications.">&2;tput sgr0;
            echo "Find local application.";
            SAM_INSTALL_REPO_ID='';
        fi;
        SAM_INSTALL_DOCKER_ID=`docker images | grep -v 'REPOSITORY' | awk -F ' ' ' {print $1,$2,$3} ' | sed "s/ /:/g" | grep "$SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION:" | awk -F ':' '{print $NF}'`;
        if [[ -z $SAM_INSTALL_DOCKER_ID ]];then
            echo -e "\E[31mERROR: Not found smilart applications '$SAM_INSTALL_APP:$SAM_INSTALL_VERSION'.">&2;tput sgr0;
            exit 1;
        fi;
        docker logout 2>&1 > /dev/null;
    fi;

    # if exist label com.smilart.multiple_versions="supported"
    check_app_in_db $SAM_INSTALL_DOCKER_ID $SAM_INSTALL_APP $SAM_INSTALL_VERSION
    # 

    create_tag_app $SAM_INSTALL_DOCKER_ID $SAM_INSTALL_APP:$SAM_INSTALL_VERSION;
    echo;
    echo -e "\E[32mInstalling app $SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION.";tput sgr0;
    install_app_func $SAM_INSTALL_DOCKER_ID;    
    save_app_in_db $SAM_INSTALL_DOCKER_ID $SAM_INSTALL_APP $SAM_INSTALL_VERSION $SAM_INSTALL_REPO_ID;
    if [[ $? -ne 0 ]]; then
        echo -e "\E[31mERROR: Not save in db. '$SAM_INSTALL_DOCKER_ID $SAM_INSTALL_APP $SAM_INSTALL_VERSION $SAM_INSTALL_REPO_ID'">&2;tput sgr0;
        exit 1;
    fi;
    echo -e "\E[32mApp $SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION installed.";tput sgr0;
    echo;
}

upgrade_func(){
    local PATH_UPDATE_SMILARTOS='/etc/coreos/update.conf';
    local SAM_URL_UPDATE;
    local I;

    if [ -e $1 ];then
        SAM_URL_UPDATE="http://localhost:8002/"
    else
        SAM_URL_UPDATE="$1"; 
    fi;

    #Test url
    I=0;
    while [ $I -lt 3 ]; do
        I=$[$I+1];
        curl "$SAM_URL_UPDATE" > /dev/null 2>&1;
        if [ $? -ne 0 ];then
            echo -e "\E[33mWARN: Server update is not available. Reconnect after 3 seconds..";tput sgr0;
            sleep 3;
            continue;
        else
            break;
        fi;
    done;
    if [ $I -eq 3 ];then
        echo -e "\E[31mERROR: Stop upgrading. Url $SAM_URL_UPDATE is bad.">&2;tput sgr0;
        exit 1;
    fi;
    unset I;

    #Configure update-engine
    echo "GROUP=stable
REBOOT_STRATEGY=off
SERVER=$SAM_URL_UPDATE" > $PATH_UPDATE_SMILARTOS;
    #Restarting update-engine
    sudo systemctl restart update-engine;
    #Start update
    update_engine_client -update;
}

remove_func(){
    local SAM_REMOVE_NAME;
    local COUNT_APPS_NAME;
    local SAM_REMOVE_VERSION;
    local SAM_REMOVE_DOCKER_ID;

    SAM_REMOVE_NAME="`echo $1 | awk -F ':' '{print $1}'`"

    COUNT_APPS_NAME=`sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_REMOVE_NAME'" | wc -l`    
    case "$COUNT_APPS_NAME" in
        "0") echo -e "\E[31mERROR: App $SAM_REMOVE_NAME not found in db.">&2;tput sgr0;
             exit 1
            ;;

        "1") if [[ -z "`echo $1 | grep ':'`" ]];then
                 SAM_REMOVE_VERSION=`sqlite3 $SAM_DB_SQLITE "SELECT ImageVersion from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_REMOVE_NAME'"`
             else
                 SAM_REMOVE_VERSION="`echo $1 | awk -F ':' '{print $2}'`"
             fi;   
            ;;

        *) SAM_REMOVE_VERSION="`echo $1 | awk -F ':' '{print $2}'`"
          ;;
    esac
   
    SAM_REMOVE_DOCKER_ID="`sqlite3 $SAM_DB_SQLITE \"SELECT DockerId from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_REMOVE_NAME' AND ImageVersion='$SAM_REMOVE_VERSION'\"`"
    if [[ -z "$SAM_REMOVE_DOCKER_ID" || "`echo \"$SAM_REMOVE_DOCKER_ID\" | wc -l`" != "1" ]];then
        echo -e "\E[31mERROR: App $SAM_REMOVE_NAME:$SAM_REMOVE_VERSION not found in db.">&2;tput sgr0;
             exit 1;
    fi;

    echo;
    echo -e "\E[32mUninstalling app $SAM_REMOVE_NAME:$SAM_REMOVE_VERSION.";tput sgr0;
    uninstall_app_func $SAM_REMOVE_DOCKER_ID;
    delete_app_to_db_func $SAM_REMOVE_DOCKER_ID;
    echo -e "\E[32mApp $SAM_REMOVE_NAME:$SAM_REMOVE_VERSION uninstalled.";tput sgr0;
}

list_func(){

local LIST_APPS
local LIST_APPS_MAX_LINE

if [ -z "$GETOPT_RAW" ];then
        echo;
        echo "      List apps:";
        echo;
        # Print repository
        LIST_APPS=`sqlite3 -header $SAM_DB_SQLITE "SELECT ImageName as Name,ImageVersion as Version,CASE ImageRepos WHEN null THEN 'unknown' WHEN 0 THEN 'archive' ELSE (SELECT ReposName FROM $SAM_DB_TABLE_REPOS WHERE ImageRepos=Repos.Id) END as Repository FROM $SAM_DB_TABLE_INSTALL_APPS"`;
        if [[ -n $LIST_APPS ]];then
            LIST_APPS_MAX_LINE=`echo "$LIST_APPS" | column -t -s '|' -o ' | ' | wc -L`;
            echo "$LIST_APPS" | column -t -s '|' -o ' | ' | sed -e "1 a `for i in \`seq 1 $LIST_APPS_MAX_LINE\`; do echo -n '-';  done`";
        echo;
        fi;
else
        sqlite3 $SAM_DB_SQLITE "SELECT ImageName,ImageVersion,ImageRepos,CASE ImageRepos WHEN null THEN 'unknown' WHEN 0 THEN 'archive' ELSE (SELECT ReposName FROM $SAM_DB_TABLE_REPOS WHERE ImageRepos=Repos.Id) END FROM $SAM_DB_TABLE_INSTALL_APPS";
fi;
}

info_func(){

    local TEMPLATE_DIR
    local SAM_INFO_APP
    local SAM_INFO_DOCKER_ID

    SAM_INFO_APP=$1
    if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_INFO_APP'"` ]];then
        echo -e "\E[31mERROR: App not found in db.">&2;tput sgr0;
        exit 1;
    fi;
    SAM_INFO_DOCKER_ID=`sqlite3 $SAM_DB_SQLITE "SELECT DockerId from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_INFO_APP'"`;
    copy_meta_func $SAM_INFO_DOCKER_ID;
    pwd=$PWD;
    cd $TEMPLATE_DIR/meta;
    echo;
    cat DESCRIPTION;
    echo;
    echo "    Time of creation:";
    cat BUILDSTAMP;
    cd $pwd;
    rm -rf $TEMPLATE_DIR;
    echo;
}

addrepo_func(){
    #It is correct name and url?
    if [[ -z $GETOPT_NAME ]] || [[ -z $GETOPT_SERVER ]];then
         echo "$USAGE_ADDREPO";
         echo -e "\E[31mERROR: Argument for 'sam addrepo' is not correct.">&2;tput sgr0;
         exit 1;
    fi;
    #Exist name in db?
    if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposName='$GETOPT_NAME'"` ]];then
         echo -e "\E[31mERROR: Repository name '$GETOPT_NAME' exist in db.">&2;tput sgr0;
         exit 1;
    fi;
    GETOPT_PASSWORD=`echo "$GETOPT_PASSWORD" | base64`

    #save in db
    sqlite3 $SAM_DB_SQLITE "insert into $SAM_DB_TABLE_REPOS (ReposFlag,ReposName,ReposUrl,ReposUser,ReposPass,ReposEmail) values ('$GETOPT_DEFAULT','$GETOPT_NAME','$GETOPT_SERVER','$GETOPT_USERNAME','$GETOPT_PASSWORD','$GETOPT_EMAIL');";
    if [[ -n $GETOPT_DEFAULT ]];then
       sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposFlag=''";
       sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposFlag='*' where ReposName='$GETOPT_NAME'";
    fi;
}

removerepo_func(){
    # $1 is name or id repository
    #Found repo name in db?
    if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposName='$1'"` ]];then
        #delete in db
        #Default repository?
        if [[ '*' == `sqlite3 $SAM_DB_SQLITE "select ReposFlag from $SAM_DB_TABLE_REPOS where ReposName='$1'"` ]]; then
                echo -e "\E[31mERROR: Repository with name '$1' is default.">&2;tput sgr0;
                exit 1;
        fi;
        sqlite3 $SAM_DB_SQLITE "delete from $SAM_DB_TABLE_REPOS where ReposName='$1'";

    #Found id in db?
    elif [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT Id from $SAM_DB_TABLE_REPOS where Id='$1'"` ]];then
        #delete in db
        #Default repository?
        if [[ '*' == `sqlite3 $SAM_DB_SQLITE "select ReposFlag from $SAM_DB_TABLE_REPOS where Id='$1'"` ]]; then
                echo -e "\E[31mERROR: Repository with number '$1' is default.">&2;tput sgr0;
                exit 1;
        fi;
        sqlite3 $SAM_DB_SQLITE "delete from $SAM_DB_TABLE_REPOS where Id='$1'";
    else
            echo -e "\E[31mERROR: Repository name and number '$1' not found in db.">&2;tput sgr0;
            exit 1;
    fi;
}

modifyrepo_func(){
    #It is correct name and url?
    if [[ -z $1 ]];then
         echo "$USAGE_MODIFYREPO";
         echo -e "\E[31mERROR: Argument id repository for 'sam modifyrepo' is not correct.">&2;tput sgr0;
         exit 1;
    fi;
    if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT Id from $SAM_DB_TABLE_REPOS where Id='$1'"` ]];then
        echo -e "\E[31mERROR: Repository number '$1' not found in db.">&2;tput sgr0;
        exit 1;
    fi;
    GETOPT_NAME=`[[ -z $GETOPT_NAME ]] && sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where id='$1'" || echo $GETOPT_NAME`;
    GETOPT_SERVER=`[[ -z $GETOPT_SERVER ]] && sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where id='$1'" || echo $GETOPT_SERVER`;
    GETOPT_USERNAME=`[[ -z $GETOPT_USERNAME ]] && sqlite3 $SAM_DB_SQLITE "SELECT ReposUser from $SAM_DB_TABLE_REPOS where id='$1'" || echo $GETOPT_USERNAME`;
    GETOPT_PASSWORD=`[[ -z $GETOPT_PASSWORD ]] && sqlite3 $SAM_DB_SQLITE "SELECT ReposPass from $SAM_DB_TABLE_REPOS where id='$1'" || echo $GETOPT_PASSWORD | base64`;
    GETOPT_EMAIL=`[[ -z $GETOPT_EMAIL ]] && sqlite3 $SAM_DB_SQLITE "SELECT ReposEmail from $SAM_DB_TABLE_REPOS where id='$1'" || echo $GETOPT_EMAIL`;
    sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposName='$GETOPT_NAME',ReposUrl='$GETOPT_SERVER',ReposUser='$GETOPT_USERNAME',ReposPass='$GETOPT_PASSWORD',ReposEmail='$GETOPT_EMAIL' where id='$1'";
    if [[ $GETOPT_DEFAULT == '*' ]];then
        sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposFlag=''";
        sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposFlag='*' where id='$1'";
    fi;
}

listrepos_func(){

    local LIST_REPOSITORIES_MAX_LINE
    local LIST_REPOSITORIES

    if [ -z "$GETOPT_RAW" ];then
        echo;
        echo "      List repositories:";
        echo;
        LIST_REPOSITORIES=`sqlite3 -header $SAM_DB_SQLITE "SELECT id as Num, ReposFlag as Def, ReposName as Name, ReposUrl as Url, ReposUser as User FROM $SAM_DB_TABLE_REPOS" |  column -t -s '|' -o ' | '`;
        LIST_REPOSITORIES_MAX_LINE=`echo "$LIST_REPOSITORIES" | wc -L`;
        echo "$LIST_REPOSITORIES" | sed -e "1 a `for i in \`seq 1 $LIST_REPOSITORIES_MAX_LINE\`; do echo -n '-';  done`"
        echo;
    else
        sqlite3 $SAM_DB_SQLITE "SELECT id, ReposFlag, ReposName, ReposUrl, ReposUser, ReposEmail FROM $SAM_DB_TABLE_REPOS";
    fi;
}

search_func(){

    local SAM_INSTALL_REPOS_NAME
    local SAM_INSTALL_PASSWORD
    local SAM_INSTALL_REPOS_URL
    local SAM_INSTALL_USER
    local CURRENT_VERSION
    local CURRENT_IMAGE
    local LIST_IMAGES
    local FLUG_SHOW_VERSIONS

    #Exist repository in db?
    SAM_INSTALL_REPOS_NAME=`sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposFlag='*'" | sed 's/\/$//' | awk -F '/' '{print $NF}'`
    if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"` ]];then
        echo -e "\E[31mERROR: Not found default repository in db.">&2;tput sgr0;
        exit 1;
    fi;
    #Reade info from db
    SAM_INSTALL_PASSWORD=`sqlite3 $SAM_DB_SQLITE "SELECT ReposPass from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'" | base64 -d`;
    SAM_INSTALL_REPOS_URL=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"`;
    #Get list images
    SAM_INSTALL_USER=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUser from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'" | sed 's/[\ \t]//g'`;
    if [ -n $SAM_INSTALL_USER ];then
        SAM_INSTALL_REPOS_URL=$SAM_INSTALL_USER:$SAM_INSTALL_PASSWORD@$SAM_INSTALL_REPOS_URL;
    fi;
    #Get version images to repository
    CURRENT_IMAGE='';
    CURRENT_VERSION='';
    echo > $SAM_HISTORY;
    echo;
    echo "      List image versions:";
    echo;

    LIST_IMAGES="`curl https://$SAM_INSTALL_REPOS_URL/v2/_catalog -s | awk -F '[' '{print $NF}' | awk -F ']' '{print $1}' | sed 's/,/,\n/g' | awk -F '"' '{print $2}'`"

    for CURRENT_IMAGE in `echo "$LIST_IMAGES"`
    do
        if [ -n "`echo \"$CURRENT_IMAGE\" | grep \"$1\"`" ];then
            FLUG_SHOW_VERSIONS=true
        else
            FLUG_SHOW_VERSIONS=false
        fi;

        if [[ ${FLUG_SHOW_VERSIONS} == true ]];then
            echo -n -e "\E[33m$CURRENT_IMAGE" | tr -d '\n' ; tput sgr0;
        fi;
        local sumb_brake=':'
        for CURRENT_VERSION in `curl https://$SAM_INSTALL_REPOS_URL/v2/$CURRENT_IMAGE/tags/list -s | awk -F '[' '{print $NF}' | awk -F ']' '{print $1}' | sed -E 's/\"//g;s/,/\n/g' | sort --version-sort -r`
        do
                if [[ ${FLUG_SHOW_VERSIONS} == true ]];then
                        echo -n -e "$sumb_brake$CURRENT_VERSION" | tr -d '\n';
                        sumb_brake=', '
                fi;

                echo "${CURRENT_IMAGE}:${CURRENT_VERSION}" >> $SAM_HISTORY
        done;

        if [[ ${FLUG_SHOW_VERSIONS} == true ]];then
            echo 
        fi;
    done;
}

purge_func(){
        local PURGE_LIST_APPS="`sqlite3 $SAM_DB_SQLITE \"SELECT DockerId FROM $SAM_DB_TABLE_INSTALL_APPS\"`"
        local CHECK_APP
        echo -e "Creating image checklist.\n"
        local CHECKLIST="`docker images -q`"
        echo -e "\nStarting garbage collect of sam apps.\n";
        for CHECK_APP in `echo "$CHECKLIST"`
        do
            if [[ -z `echo "$PURGE_LIST_APPS" | grep "$CHECK_APP"` ]];then
                docker rmi -f "$CHECK_APP"
                echo
            fi
        done

        echo -e "\E[32mCollecting garbage is complete.";tput sgr0;

}

help_func(){
    case $1 in
        install|in)
            echo "$USAGE_INSTALL";
            exit 0
            ;;
        upgrade|up)
            echo "$USAGE_UPGRADE";
            exit 0
            ;;
        remove|rm)
            echo "$USAGE_REMOVE";
            exit 0
            ;;
        list)
            echo "$USAGE_LIST";
            exit 0
            ;;
	purge)
            echo "$USAGE_PURGE";
            exit 0
            ;;
        info)
            echo "$USAGE_INFO";
            exit 0
            ;;
        addrepo|ar)
            echo "$USAGE_ADDREPO";
            exit 0
            ;;
        removerepo|rr)
            echo "$USAGE_REMOVEREPO";
            exit 0
            ;;
        modifyrepo|mr)
            echo "$USAGE_MODIFYREPO";
            exit 0
            ;;
        listrepos|lr)
            echo "$USAGE_LISTREPOS";
            exit 0
            ;;
        search|se)
            echo "$USAGE_SEARCH";
            exit 0
            ;;
        *)
            echo "$USAGE";
            echo;
            ;;
    esac
}

###Case section
SAM_ARGUMENT=`getopt -o h:x --long help:,debug,raw,default,name:,server:,username:,password:,email: --name "sam" -- "$@"`
eval set -- "$SAM_ARGUMENT";
unset SAM_ARGUMENT;
unset GETOPT_RAW;
unset GETOPT_DEFAULT;
unset GETOPT_NAME;
unset GETOPT_SERVER;
unset GETOPT_USERNAME;
unset GETOPT_PASSWORD;
unset GETOPT_EMAIL;

while true ; do
    case "$1" in
        -h|--help)
            shift;
            help_func $@;
            exit 0
            ;;
        -x|--debug)
            set -vx;
            shift
            ;;
        --raw)
            GETOPT_RAW='*';
            shift
            ;;
        --default)
            GETOPT_DEFAULT='*';
            shift
            ;;
        --name)
            GETOPT_NAME=$2;
            shift 2
            ;;
        --server)
            GETOPT_SERVER=$2;
            shift 2
            ;;
        --username)
            GETOPT_USERNAME=$2;
            shift 2
            ;;
        --password)
            GETOPT_PASSWORD=$2;
            shift 2
            ;;
        --email)
            GETOPT_EMAIL=$2;
            shift 2
            ;;
        --)
            shift;
            case "$1" in
                help)
                    shift;
                    help_func $@;
                    exit 0
                    ;;
                addrepo|ar)
                    shift;
                    addrepo_func;
                    exit 0
                    ;;
                listrepos|lr)
                    shift;
                    listrepos_func;
                    exit 0
                    ;;
                search|se)
                    shift;
                    search_func $1;
                    exit 0
                    ;;
                removerepo|rr)
                    shift;
                    removerepo_func $1;
                    exit 0
                    ;;
                modifyrepo|mr)
                    shift;
                    modifyrepo_func $1;
                    exit 0
                    ;;
                list)
                    shift;
                    list_func;
                    exit 0
                    ;;
		purge)
		    shift;
                    purge_func;
                    exit 0
                    ;;
                install|in)
                    shift;
                    install_func $1;
                    exit 0
                    ;;
                remove|rm)
                    shift;
                    remove_func $1;
                    exit 0
                    ;;
                upgrade|up)
                    shift;
                    upgrade_func $1;
                    exit 0
                    ;;
                info)
                    shift;
                    info_func $1;
                    exit 0
                    ;;
            esac
            ;;
        *)
            echo "$USAGE";
            echo;
            exit 1
            ;;
    esac
done
