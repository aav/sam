#!/bin/bash

#set -vx
SAM_VERSION='1.13';

#Configuring
BIN_DIR=${BIN_DIR:-/opt/bin}
SAM_DB_SQLITE=${SAM_DB_SQLITE:-/var/db/sam/smilart.db}
SAM_HISTORY=${SAM_HISTORY:-/var/db/sam/history}

## Functions
# Copy META from image
# copy_meta_func <DockerId>
copy_meta_func() {
        local file

        TEMPLATE_DIR=`mktemp -d`;
        docker run -i -t --rm -v $TEMPLATE_DIR:$TEMPLATE_DIR  --net=host --entrypoint="cp" $1 -r /meta $TEMPLATE_DIR/meta 2>&1 > /dev/null;
        if [[ $? -ne 0 ]]; then
                echo -e "\E[31mERROR: Invalid image format. Directory '/meta' doesn't exist in the image.">&2;tput sgr0;
                rm -rf $TEMPLATE_DIR;
                if [ -n `sqlite3 $SAM_DB_SQLITE "select ImageName from $SAM_DB_TABLE_INSTALL_APPS where DockerId=$1"` ] ; then
                    read -r -p "Remove the application from sam repository? [y/N] " response
                    case $response in
                        [yY][eE][sS]|[yY])
                          delete_app_to_db_func $1;
                          exit 0
                          ;;
                        *)
                          exit 0
                          ;;
                    esac
                else
                    exit 1;
                fi;
        fi;
        # Remove files *.expand
        for file in $(find $TEMPLATE_DIR/meta -type f -name "*.expand"); do
           rm -f $file;
        done
}

# Uninstall apps function
# uninstall_app_func <DockerId>
uninstall_app_func() {
        copy_meta_func $1;
        pwd=$PWD;
        cd $TEMPLATE_DIR/meta;
        source $TEMPLATE_DIR/meta/uninstall;
        cd $pwd;
        rm -rf $TEMPLATE_DIR;
        echo;
        unset TEMPLATE_DIR;
}

# Install apps function
# install_app_func <DockerId>
install_app_func() {
        copy_meta_func $1;
        pwd=$PWD;
        cd $TEMPLATE_DIR/meta;
        echo;
        source $TEMPLATE_DIR/meta/install;
        cd $pwd;
        rm -rf $TEMPLATE_DIR;
        echo;
        unset TEMPLATE_DIR;
}

# create_tag_app <DockerId> <app>:<version>
create_tag_app(){
        local SAM_APP_LABEL=`docker inspect $1 | grep -m 1 com.smilart.repo_base_name | awk -F '"'  '{print $4}'`
        if [[ -n $SAM_APP_LABEL ]];then
                echo;
                echo -e "\E[32mCreating tag '$SAM_APP_LABEL/$2'...";tput sgr0;
                docker tag $1 $SAM_APP_LABEL/$2;
                if [[ $? -ne 0 ]]; then
                    echo -e "\E[31mERROR: Cannot create tag '${SAM_APP_LABEL}/$2' for docker image $1.">&2;tput sgr0;
                    exit 1;
                fi;
        else
                echo;
                echo "Invalid image format. Label com.smilart.repo_base_name doesn't exist in the image $1.";
        fi;
}
# Delete apps in db function
# delete_app_to_db_func <DockerId>;
delete_app_to_db_func() {
        sqlite3 $SAM_DB_SQLITE "delete from $SAM_DB_TABLE_INSTALL_APPS where DockerId='$1'";
        echo "Application was removed from SAM database"
}

create_connect_func() {
        echo "Add 'connect' command in the system.";
        echo '#!/bin/bash 

connect_func(){
PID=`/usr/bin/docker inspect --format {{.State.Pid}} $1`;
if [ -z $PID ]; then
        echo -e "\E[31mContainer $1 is not found."; tput sgr0;
else
        if [ $PID -eq 0 ]; then
                echo -e "\E[31mContainer $1 is not started.";tput sgr0;
        else
                echo -e "\E[32mConnect to container $1."; tput sgr0;
                /usr/bin/docker exec -i -t $1 /bin/bash -c "cd /root ; TERM=xterm HOME=/root /bin/bash";
        fi;
fi;
}

connect_func $@;' > $BIN_DIR/connect;
        chmod +x $BIN_DIR/connect;
}

# save_app_in_db <DockerId> <ImageName> <ImageVersion> <ImageRepos NUMBER>
save_app_in_db(){
    local LABEL_MULTIVERSION;
    if [[ `docker inspect $1 | grep -m 1 com.smilart.multiple_versions | awk -F '"'  '{print $4}'` == "supported" ]];then
            LABEL_MULTIVERSION='*';
    else
            LABEL_MULTIVERSION='';
    fi;

    local LABEL_FAMILY=`docker inspect $1 | grep -m 1 com.smilart.family | awk -F '"'  '{print $4}'`;
    if [[ -z "$LABEL_FAMILY" ]];then
        LABEL_FAMILY="$2"; 
    fi;

    sqlite3 $SAM_DB_SQLITE "insert into $SAM_DB_TABLE_INSTALL_APPS (DockerId,ImageName,ImageVersion,ImageRepos,MultiVersion,Family) values ('$1','$2','$3','$4','$LABEL_MULTIVERSION','$LABEL_FAMILY');";
    echo "Application was saved in SAM database."
}

# check_app_in_db <DockerId> <ImageName> <ImageVersion>
#if app exist or not found label com.smilart.multiple_versions="supported" then error
check_app_in_db(){
    # This function return exit code 1 if executed conditions
    # exist fullname
    if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$2' AND ImageVersion='$3'"` ]];then
        echo -e "\E[31mERROR: Application '$2:$3' already exists in SAM database.">&2;tput sgr0;
        return 1;
    fi;
    # exist with docker id
    if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where DockerId='$1'"` ]];then
        echo -e "\E[31mERROR: Application with docker image id '$1' already exists in SAM database.">&2;tput sgr0;
        return 1;
    fi;

    # if app have label multiversion
    local LABEL_MULTIVERSION=`docker inspect $1 | grep -m 1 com.smilart.multiple_versions | awk -F '"'  '{print $4}'`;
    local LABEL_FAMILY=`docker inspect $1 | grep -m 1 com.smilart.family | awk -F '"'  '{print $4}'`;
    if [[ -z "$LABEL_FAMILY" ]];then
        LABEL_FAMILY="$2";
    fi;
    if [[ "$LABEL_MULTIVERSION" == "supported" ]];then
        # and if name exist in db among without multiversion
        if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$2' AND MultiVersion=''"` ]];then
            echo -e "\E[31mERROR: Application with name '$2' already exists in SAM database.">&2;tput sgr0;
            return 1;
        fi;
        # and if family exist in db among without multiversion
        if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where Family='$LABEL_FAMILY' AND MultiVersion=''"` ]];then
             echo -e "\E[31mERROR: Application with family '$LABEL_FAMILY' already exists in SAM database.">&2;tput sgr0;
             return 1;
        fi;
    else
    # if app doesn't have label multiversion
        # and if name exist in db
        if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$2'"` ]];then
            echo -e "\E[31mERROR: Application with name '$2' already existis in SAM database.">&2;tput sgr0;
            return 1;
        fi;
        # and if family exist in db
        if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where Family='$LABEL_FAMILY'"` ]];then
             echo -e "\E[31mERROR: Application with family '$LABEL_FAMILY' already exists in SAM database.">&2;tput sgr0;
             return 1;
        fi;
    fi;
}

# pull_image_from_repo <ImageName> <ImageVersion>
pull_image_from_repo(){
    local DOCKER_LOGIN_USER=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUser from $SAM_DB_TABLE_REPOS where ReposFlag='*'" | sed 's/[\ \t]//g'`;
    local DOCKER_LOGIN_PASSWORD='';
    local PREFIX_IMAGE_DOCKER=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where ReposFlag='*'" | sed 's/\/$//' | awk -F '/' '{print $NF}'`;
    local DOCKER_LOGIN_REPOS_URL='';

    if [[ -n $DOCKER_LOGIN_USER ]];then
        DOCKER_LOGIN_PASSWORD=`sqlite3 $SAM_DB_SQLITE "SELECT ReposPass from $SAM_DB_TABLE_REPOS where ReposFlag='*'"`;
        DOCKER_LOGIN_REPOS_URL=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where ReposFlag='*'"`;
        docker login --username=$DOCKER_LOGIN_USER --password=`echo "$DOCKER_LOGIN_PASSWORD" | base64 -d` $PREFIX_IMAGE_DOCKER 2>&1 > /dev/null;
        if [[ $? -ne 0 ]]; then
            echo -e "\E[31mERROR: Wrong login/password or repository url.">&2;tput sgr0;
            exit 1;
        fi;
    fi;
    docker pull $PREFIX_IMAGE_DOCKER/$1:$2;
    if [[ $? -ne 0 ]];then
        return 1
    fi;
}

## Testing
#
if [[ ! -d /var/db/sam ]];then
        mkdir -p '/var/db/sam';
fi;

if [[ -z `which docker` ]]; then
        echo -e "\E[31mERROR: Command 'docker' not found in the system.">&2;tput sgr0;
        exit 1;
fi;

# This root?
if [[ $EUID -ne 0 ]]; then
        echo -e "\E[31mThis script must be run as root">&2;tput sgr0;
        exit 1;
fi

# Exist BIN_DIR dirrectory ?
if ! [[ -d $BIN_DIR ]]; then
        echo "Creating $BIN_DIR...";
        mkdir -p $BIN_DIR;
fi

# Exist BIN_DIR in path ?
if [[ -z `echo $PATH | grep $BIN_DIR` ]]; then
        echo -e "\E[31mERROR: Path '$BIN_DIR' not found in variable \$PATH. You must add '$BIN_DIR' to \$PATH.">&2;tput sgr0;
        exit 1;
fi;

# Exist command 'connect'?
if ! [[ -f $BIN_DIR/connect ]]; then
        create_connect_func;
        echo;
fi;

# Exist command sqlite3
if [[ -z `which sqlite3` ]]; then
        echo -e "\E[31mERROR: Command 'sqlite3' not found in the system.">&2;tput sgr0;
        exit 1;
fi;

# Exist db?
SAM_DB_TABLE_INSTALL_APPS="Apps";
if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT name FROM sqlite_master WHERE type='table' AND name='$SAM_DB_TABLE_INSTALL_APPS'"` ]];then
        echo;
        echo "Creating table $SAM_DB_TABLE_INSTALL_APPS...";
        echo;
        sqlite3 $SAM_DB_SQLITE "create table $SAM_DB_TABLE_INSTALL_APPS (id INTEGER PRIMARY KEY,DockerId TEXT,ImageName TEXT,ImageVersion TEXT,ImageRepos INTEGER,MultiVersion TEXT,Family TEXT);";
fi;

SAM_DB_TABLE_REPOS="Repos";
SAM_DB_TABLE_REPOS_URL="smilart";
if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT name FROM sqlite_master WHERE type='table' AND name='$SAM_DB_TABLE_REPOS'"` ]];then
        echo;
        echo "Creating table $SAM_DB_TABLE_REPOS...";
        echo;
        sqlite3  $SAM_DB_SQLITE "create table $SAM_DB_TABLE_REPOS (id INTEGER PRIMARY KEY,ReposFlag TEXT,ReposName TEXT,ReposUrl, TEXT, ReposUser TEXT, ReposPass TEXT);";
        echo "Adding default repository: $SAM_DB_TABLE_REPOS_URL"...;
        echo;
        sqlite3 $SAM_DB_SQLITE "insert into $SAM_DB_TABLE_REPOS (ReposFlag,ReposName,ReposUrl,ReposUser,ReposPass) values ('*','official','$SAM_DB_TABLE_REPOS_URL','','');";
fi;

if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposFlag='*'"` ]];then
    echo -e "\E[31mERROR: Cannot find default repository in SAM database.">&2;tput sgr0;
    exit 1;
fi;

# Converting db to db with multiversion
convert_with_multiversion(){
    local APPS_ID;
    local LABEL_MULTIVERSION;

    if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT DockerId from $SAM_DB_TABLE_INSTALL_APPS"` ]];then
        return 0;
    fi;

    for APPS_ID in `sqlite3 $SAM_DB_SQLITE "SELECT DockerId from $SAM_DB_TABLE_INSTALL_APPS"`
    do
        if [[ `docker inspect $APPS_ID | grep -m 1 com.smilart.multiple_versions | awk -F '"'  '{print $4}'` == "supported" ]];then
            LABEL_MULTIVERSION='*';
        else
            LABEL_MULTIVERSION='';
        fi;
        sqlite3 $SAM_DB_SQLITE "UPDATE $SAM_DB_TABLE_INSTALL_APPS SET MultiVersion='$LABEL_MULTIVERSION' WHERE DockerId='$APPS_ID'";
        if [[ $? -ne 0 ]];then
            echo -e "\E[31mERROR: Cannot add label to column MultiVersion in db.">&2;tput sgr0;
        fi;
    done;
}

sqlite3 $SAM_DB_SQLITE "SELECT MultiVersion FROM $SAM_DB_TABLE_INSTALL_APPS" > /dev/null 2>&1;
if [[ $? -ne 0 ]];then
     echo -e "\E[33mWARN: Db of sam doesn't contain information about multiversion support.";tput sgr0; 
     echo "Creating column MultiVersion to $SAM_DB_TABLE_INSTALL_APPS.";
     sqlite3 $SAM_DB_SQLITE "ALTER TABLE $SAM_DB_TABLE_INSTALL_APPS ADD COLUMN MultiVersion TEXT";
     if [[ $? -ne 0 ]];then
         echo -e "\E[31mERROR: Cannot create column MultiVersion in db.">&2;tput sgr0;
         exit 1;
     fi;

     #For sqlite3 3.13 (else not found new column)
     sqlite3 $SAM_DB_SQLITE "VACUUM";

     convert_with_multiversion;
fi;

# Converting db to db with family
convert_with_family(){
    local APPS_ID;
    local APPS_NAME;
    local LABEL_FAMILY;

    if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT DockerId from $SAM_DB_TABLE_INSTALL_APPS"` ]];then
        return 0;
    fi;

    for APPS_ID in `sqlite3 $SAM_DB_SQLITE "SELECT DockerId from $SAM_DB_TABLE_INSTALL_APPS"`
    do
        APPS_NAME=`sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where DockerId='$APPS_ID'"`;
        LABEL_FAMILY=`docker inspect $APPS_ID | grep -m 1 com.smilart.family | awk -F '"'  '{print $4}'`;
        if [[ -z "$LABEL_FAMILY" ]];then
            LABEL_FAMILY=$APPS_NAME;
        fi;
        sqlite3 $SAM_DB_SQLITE "UPDATE $SAM_DB_TABLE_INSTALL_APPS SET Family='$LABEL_FAMILY' WHERE DockerId='$APPS_ID'";
        if [[ $? -ne 0 ]];then
            echo -e "\E[31mERROR: Cannot add label to column Family in db.">&2;tput sgr0;
        fi;
    done;
}

sqlite3 $SAM_DB_SQLITE "SELECT Family FROM $SAM_DB_TABLE_INSTALL_APPS" > /dev/null 2>&1;
if [[ $? -ne 0 ]];then
     echo -e "\E[33mWARN: SAM database doesn't contain information about family support.";tput sgr0;
     echo "Creating column Family to $SAM_DB_TABLE_INSTALL_APPS.";
     sqlite3 $SAM_DB_SQLITE "ALTER TABLE $SAM_DB_TABLE_INSTALL_APPS ADD COLUMN Family TEXT";
     if [[ $? -ne 0 ]];then
         echo -e "\E[31mERROR: Cannot create column Family in db.">&2;tput sgr0;
         exit 1;
     fi;

     #For sqlite3 3.13 (else not found new column)
     sqlite3 $SAM_DB_SQLITE "VACUUM";

     convert_with_family;
fi;

## Help section
USAGE="
  Usage:
        sam [--global-options] <command> [--command-options] [arguments]

  Global Options:
        --help, -h              Help.
        --debug, -x             Debug mode.


  Commands:
        help                    Print help.

     Software Management:
        install, in             Install applications.
        remove, rm              Remove applications.
        purge                   Clear docker images isn't registered in SAM database.
        list                    List installed applications.
        search, se              Search image version in remote repository.
        info                    Print application info.
     
        export, ex              Export images list or archive.
        import, im              Import images list or archive.

     Repository Management:
        addrepo, ar             Add a new repository.
        removerepo, rr          Remove specified repository.
        modifyrepo, mr          Modify specified repository.
        listrepos, lr           List all defined repositories.

  Version SAM v$SAM_VERSION

";

USAGE_INSTALL="
install (in) <app>:<version>
install (in) <filename>

Install smilart application with specified capabilities from repository or from gzip/tar archive.

";

USAGE_REMOVE="
remove (rm) <app>[:<version>]

Remove smilart application with specified capabilities.

";

USAGE_SEARCH="
search (se) [<image_name>]

Search application in remote repository.
WARN: Search doesn't work in official Docker Hub repository.

";

USAGE_LIST="
list [options]

List all installed Smilart applications.

  Command options:
    --raw                       List all installed Smilart applications in RAW format.
    --labels                    List all installed applications with labels.

";

USAGE_INFO="
info <name>

Print application info.

";

USAGE_ADDREPO="
addrepo (ar) --name <name> --server <hostname> [--default] [--username <username>] [--password <password>]

Add a repository to the system.

  Command options:
    --name                      Repository name. Use only to manage this repository.
    --server                    IP-address or hostname of the remote repository.
    --default                   Use this repository as default repository. It means that you can ommit repository name in sam install command.
    --username                  Username to log on the remote repository.
    --password                  Password to log on the remote repository.

";

USAGE_REMOVEREPO="
removerepo (rr) <id>|<name>

Remove repository specified by name or number.

";

USAGE_PURGE="
purge

Run removing old images from the system.

";

USAGE_MODIFYREPO="
modifyrepo (mr) <id> [--default] [--name <name>] [--server <hostname>] [--username <username>] [--password <password>]

Modify properties of repositories specified.

  Command options:
    --default                   Mark the repository as default.
    --name                      New name of the repository.
    --server                    New IP-address or new hostname of the repository.
    --username                  New username to log on the remote repository.
    --password                  New password to log on the remote repository.

";

USAGE_EXPORT="
export (ex) <file> [--all]

Export applications list in a special format to a <file>.

  Command options:
    --all                       Save applications to gzip archive and add them to tar. Export to archive.

";

USAGE_IMPORT="
import (im) <file> [--restore]

Import applications list or archive with applications.

  Command options:
    --restore                   Uninstall all installed applications and import new applications from <file>.

";

USAGE_LISTREPOS="
listrepos (lr) [--raw]

List all defined repositories.

  Command options:
    --raw                       List all defined repositories in RAW format.
";

## Function for case
install_func(){
    local SAM_INSTALL_DOCKER_ID;
    local SAM_INSTALL_REPO_ID;
    local SAM_INSTALL_VERSION;
    local SAM_INSTALL_APP;
    local SAM_INSTALL_REPOS_URL;
    local SAM_INSTALL_REPOS_NAME;
    local SAM_INSTALL_USER;
    local SAM_INSTALL_PASSWORD;
    local SAM_INSTALL_COMMAND_OPTIONS;
    local SAM_PREFIX_IMAGE_DOCKER;

    local CHECK_APP_IN_FILE;

    #Install file ot app from repos
    if [ -f "$1" ];then
        # Find file "repositories" (check format app)
        CHECK_APP_IN_FILE="`tar -xOf $1 repositories 2>&1`";
        if [[ $? -ne 0 ]]; then
            echo -e "\E[31mERROR: Invalid file format. File 'repositories' not found in '$1' or archive is corrupted..">&2;tput sgr0;
            exit 1;
        fi;
        if [[ -z "$CHECK_APP_IN_FILE" ]]; then
            echo -e "\E[31mERROR: Invalid file format. Unknown problem.">&2;tput sgr0;
            exit 1;
        fi;

        SAM_PREFIX_IMAGE_DOCKER=`echo "$CHECK_APP_IN_FILE" | awk -F '"' ' {print $2} ' | sed "s/ /:/g" | awk -F '/' '{print $1}'`;
        SAM_INSTALL_APP=`echo "$CHECK_APP_IN_FILE" | awk -F '"' ' {print $2} ' | sed "s/ /:/g" | awk -F '/' '{print $NF}'`;
        SAM_INSTALL_VERSION=`echo "$CHECK_APP_IN_FILE" | awk -F '"' ' {print $4} ' | sed "s/ /:/g"`;
        if [[ -z $SAM_PREFIX_IMAGE_DOCKER ]] || [[ -z $SAM_INSTALL_VERSION ]]; then
            echo -e "\E[31mERROR: Invalid file format. File 'repositories' is bad.">&2;tput sgr0;
            echo "Application name and/or version not found in the file 'repositories'";
            echo "Try to recreate archive.";
            exit 1;
        fi;

        echo "Loading image '$SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION'...";
        docker load -i $1;
        if [[ $? -ne 0 ]]; then
            echo -e "\E[31mERROR: Cannot load image.">&2;tput sgr0;
            exit 1;
        fi;

        SAM_INSTALL_DOCKER_ID=`docker images | grep -v 'REPOSITORY' | awk -F ' ' ' {print $1,$2,$3} ' | sed "s/ /:/g" | grep "$SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION:" | awk -F ':' '{print $NF}'`;

        SAM_INSTALL_REPO_ID=0;
    else
        # if $1 app from docker repo
        SAM_INSTALL_VERSION=`echo "$1" | awk -F '/' '{print $NF}' | awk -F ':' '{print $2}'`;
        if [[ -z $SAM_INSTALL_VERSION ]];then
            echo -e "\E[31mERROR: Invalid parameter. '$1' doesn't contain application version.">&2;tput sgr0;
            exit 1;
        fi;
        SAM_INSTALL_APP=`echo "$1" | awk -F '/' '{print $NF}' | awk -F ':' '{print $1}'`;
        SAM_INSTALL_REPOS_NAME=`echo "$1" | sed "s#\$SAM_INSTALL_APP\:\$SAM_INSTALL_VERSION##g" | sed 's/\/$//'`;
        if [[ -z $SAM_INSTALL_REPOS_NAME ]];then
            SAM_INSTALL_REPOS_NAME=`sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposFlag='*'" | sed 's/\/$//' | awk -F '/' '{print $NF}'`;
        fi;
        #Exist repository in db?
        if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"` ]];then
            echo -e "\E[31mERROR: Repository '$SAM_INSTALL_REPOS_NAME' not found in SAM database.">&2;tput sgr0;
            exit 1;
        fi;
        #logging
        SAM_INSTALL_USER=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUser from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'" | sed 's/[\ \t]//g'`;
        SAM_PREFIX_IMAGE_DOCKER=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'" | sed 's/\/$//' | awk -F '/' '{print $NF}'`;
        if [[ -n $SAM_INSTALL_USER ]];then
            SAM_INSTALL_PASSWORD=`sqlite3 $SAM_DB_SQLITE "SELECT ReposPass from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"`;
            SAM_INSTALL_REPOS_URL=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"`;
            docker login --username=$SAM_INSTALL_USER --password=`echo "$SAM_INSTALL_PASSWORD" | base64 -d` $SAM_PREFIX_IMAGE_DOCKER 2>&1 > /dev/null;
            if [[ $? -ne 0 ]]; then
                echo -e "\E[31mERROR: Wrong login/password or repository url.">&2;tput sgr0;
            fi;
        fi;
        SAM_INSTALL_REPO_ID=`sqlite3 $SAM_DB_SQLITE "SELECT Id FROM $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"`;
        # pull app
        docker pull $SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION;
        if [[ $? -ne 0 ]]; then
            echo -e "\E[33mWARN: Cannot download $SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION.">&2;tput sgr0;
            echo "Trying to find application locally...";
            SAM_INSTALL_REPO_ID='';
        fi;
        SAM_INSTALL_DOCKER_ID=`docker images | grep -v 'REPOSITORY' | awk -F ' ' ' {print $1,$2,$3} ' | sed "s/ /:/g" | grep "$SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION:" | awk -F ':' '{print $NF}'`;
        if [[ -z $SAM_INSTALL_DOCKER_ID ]];then
            echo -e "\E[31mERROR: Applications '$SAM_INSTALL_APP:$SAM_INSTALL_VERSION' not found locally.">&2;tput sgr0;
            exit 1;
        fi;
        docker logout 2>&1 > /dev/null;
    fi;

    # if exist label com.smilart.multiple_versions="supported" or com.smilart.family
    check_app_in_db $SAM_INSTALL_DOCKER_ID $SAM_INSTALL_APP $SAM_INSTALL_VERSION
    if [[ $? -ne 0 ]];then
        exit 1;
    fi;
    # 

    create_tag_app $SAM_INSTALL_DOCKER_ID $SAM_INSTALL_APP:$SAM_INSTALL_VERSION;
    echo;
    echo -e "\E[32mInstalling application '$SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION'...";tput sgr0;
    install_app_func $SAM_INSTALL_DOCKER_ID;    
    save_app_in_db $SAM_INSTALL_DOCKER_ID $SAM_INSTALL_APP $SAM_INSTALL_VERSION $SAM_INSTALL_REPO_ID;
    if [[ $? -ne 0 ]]; then
        echo -e "\E[31mERROR: Cannot save '$SAM_INSTALL_DOCKER_ID $SAM_INSTALL_APP $SAM_INSTALL_VERSION $SAM_INSTALL_REPO_ID' in SAM database">&2;tput sgr0;
        exit 1;
    fi;
    echo -e "\E[32mApplication '$SAM_PREFIX_IMAGE_DOCKER/$SAM_INSTALL_APP:$SAM_INSTALL_VERSION' was successfully installed.";tput sgr0;
    echo;
}

remove_func(){
    local SAM_REMOVE_NAME;
    local COUNT_APPS_NAME;
    local SAM_REMOVE_VERSION;
    local SAM_REMOVE_DOCKER_ID;

    SAM_REMOVE_NAME="`echo $1 | awk -F ':' '{print $1}'`";

    COUNT_APPS_NAME=`sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_REMOVE_NAME'" | wc -l`;
    case "$COUNT_APPS_NAME" in
        "0") echo -e "\E[31mERROR: Application '$SAM_REMOVE_NAME' not found in SAM database.">&2;tput sgr0;
             exit 1
            ;;

        "1") if [[ -z "`echo $1 | grep ':'`" ]];then
                 SAM_REMOVE_VERSION=`sqlite3 $SAM_DB_SQLITE "SELECT ImageVersion from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_REMOVE_NAME'"`;
             else
                 SAM_REMOVE_VERSION="`echo $1 | awk -F ':' '{print $2}'`";
             fi;   
            ;;

        *) SAM_REMOVE_VERSION="`echo $1 | awk -F ':' '{print $2}'`";
           if [[ -z $SAM_REMOVE_VERSION ]];then
               echo -e "\E[31mERROR: Application '$SAM_REMOVE_NAME' has several versions.">&2;tput sgr0;
               exit 1
           fi;
          ;;
    esac
   
    SAM_REMOVE_DOCKER_ID="`sqlite3 $SAM_DB_SQLITE \"SELECT DockerId from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_REMOVE_NAME' AND ImageVersion='$SAM_REMOVE_VERSION'\"`";
    if [[ -z "$SAM_REMOVE_DOCKER_ID" || "`echo \"$SAM_REMOVE_DOCKER_ID\" | wc -l`" != "1" ]];then
        echo -e "\E[31mERROR: Application '$SAM_REMOVE_NAME:$SAM_REMOVE_VERSION' not found in SAM database.">&2;tput sgr0;
             exit 1;
    fi;

    echo;
    echo -e "\E[32mRemoving application '$SAM_REMOVE_NAME:$SAM_REMOVE_VERSION'...";tput sgr0;
    uninstall_app_func $SAM_REMOVE_DOCKER_ID;
    delete_app_to_db_func $SAM_REMOVE_DOCKER_ID;
    echo -e "\E[32mApplication '$SAM_REMOVE_NAME:$SAM_REMOVE_VERSION' was successfully removed.";tput sgr0;
}

list_func(){

local LIST_APPS;
local LIST_APPS_MAX_LINE;

if [ -z "$GETOPT_RAW" ];then
        echo;
        echo "      List applications:";
        echo;
        # Print repository
        if [[ -z "$GETOPT_LABELS" ]];then
            LIST_APPS=`sqlite3 -header $SAM_DB_SQLITE "SELECT ImageName as Name,ImageVersion as Version,CASE ImageRepos WHEN null THEN 'unknown' WHEN 0 THEN 'archive' ELSE (SELECT ReposName FROM $SAM_DB_TABLE_REPOS WHERE ImageRepos=Repos.Id) END as Repository FROM $SAM_DB_TABLE_INSTALL_APPS"`;
        else
            LIST_APPS=`sqlite3 -header $SAM_DB_SQLITE "SELECT ImageName as Name,ImageVersion as Version,CASE ImageRepos WHEN null THEN 'unknown' WHEN 0 THEN 'archive' ELSE (SELECT ReposName FROM $SAM_DB_TABLE_REPOS WHERE ImageRepos=Repos.Id) END as Repository,Family,MultiVersion as M FROM $SAM_DB_TABLE_INSTALL_APPS"`;
        fi;
        if [[ -n $LIST_APPS ]];then
            LIST_APPS_MAX_LINE=`echo "$LIST_APPS" | sed 's/|/#|  /g' | column -t -s '#' | wc -L`;
            echo "$LIST_APPS" | sed 's/|/#|  /g' | column -t -s '#' | sed -e "1 a `for i in \`seq 1 $LIST_APPS_MAX_LINE\`; do echo -n '-';  done`";
        echo;
        fi;
else
        sqlite3 $SAM_DB_SQLITE "SELECT ImageName,ImageVersion,ImageRepos,CASE ImageRepos WHEN null THEN 'unknown' WHEN 0 THEN 'archive' ELSE (SELECT ReposName FROM $SAM_DB_TABLE_REPOS WHERE ImageRepos=Repos.Id) END FROM $SAM_DB_TABLE_INSTALL_APPS";
fi;
}

info_func(){

    local TEMPLATE_DIR;
    local SAM_INFO_APP;
    local SAM_INFO_DOCKER_ID;

    SAM_INFO_APP=$1;
    if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_INFO_APP'"` ]];then
        echo -e "\E[31mERROR: Application '$1' not found in SAM database.">&2;tput sgr0;
        exit 1;
    fi;
    SAM_INFO_DOCKER_ID=`sqlite3 $SAM_DB_SQLITE "SELECT DockerId from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$SAM_INFO_APP'"`;
    copy_meta_func $SAM_INFO_DOCKER_ID;
    pwd=$PWD;
    cd $TEMPLATE_DIR/meta;
    echo;
    cat DESCRIPTION;
    echo;
    echo "    Time of creation:";
    cat BUILDSTAMP;
    cd $pwd;
    rm -rf $TEMPLATE_DIR;
    echo;
}

export_func(){
    local FILE_PATH="$1";
    local EXPORT_LIST_APPS=`sqlite3 $SAM_DB_SQLITE "SELECT ImageName,ImageVersion FROM $SAM_DB_TABLE_INSTALL_APPS"`;
    local EXPORT_APP;
    local EXPORT_FILE_NAME;
    local PREFIX_IMAGE='smilart';
    local OS_NAME="`cat /etc/os-release | grep "PRETTY_NAME=" | awk -F '"' '{print $2}'`";
    if [[ -z "$OS_NAME" ]];then
        echo -e "\E[31mERROR: File /etc/os-release doesn't contain variable PRETTY_NAME.">&2;tput sgr0;
        exit 1;
    fi;

    echo > "$1";
    if [[ $? -ne 0 ]];then
         echo -e "\E[31mERROR: Cannot create file '$1'.">&2;tput sgr0;
         exit 1;
    fi;

    #Save to file or archive with apps
    if [[ "$GETOPT_ALL" != "true" ]];then
        echo "#$OS_NAME#" > $1;
        echo "$EXPORT_LIST_APPS" >> $1;

    else
        local TMPL_DIR=`mktemp -d`;
        echo "Creating tmp directory $TMPL_DIR"...;

        echo "Saving applications to gzip archive:"
        for EXPORT_APP in `echo "$EXPORT_LIST_APPS"`
        do
            EXPORT_FILE_NAME="`echo $EXPORT_APP | awk -F '|' '{print $1 "-" $2 ".gz"}'`";
            echo "   -> $TMPL_DIR/$EXPORT_FILE_NAME";
            docker save $PREFIX_IMAGE/`echo $EXPORT_APP | awk -F '|' '{print $1 ":" $2}'` | gzip > $TMPL_DIR/$EXPORT_FILE_NAME;
            if [[ $? -ne 0 ]];then
                echo -e "\E[31mERROR: Cannot save image.">&2;tput sgr0;
                exit 1;
            fi;

            local FPostfix=`echo "$TMPL_DIR/$EXPORT_FILE_NAME" | awk -F '.' ' {print $NF}  '`;
            local CKSUM=`cksum "$TMPL_DIR/$EXPORT_FILE_NAME" | awk ' {print $1$2} '`;
            if [[ $? -ne 0 ]];then
                echo -e "\E[31mERROR: Cannot count checksum archive '$TMPL_DIR/$EXPORT_FILE_NAME'.">&2;tput sgr0;
                exit 1;
            fi;
            local NewName=`echo "$TMPL_DIR/$EXPORT_FILE_NAME" | sed s#$FPostfix#.$CKSUM.$FPostfix#g`;
            mv $TMPL_DIR/$EXPORT_FILE_NAME $NewName;
            if [[ $? -ne 0 ]];then
                echo -e "\E[31mERROR: Cannot create file '$NewName'.">&2;tput sgr0;
                exit 1;
            fi;
        done;

        echo "Creating images list...";
        echo "#$OS_NAME#" > $TMPL_DIR/imagelist;
        if [[ $? -ne 0 ]];then
            echo -e "\E[31mERROR: Cannot create export file '$TMPL_DIR/imagelist'.">&2;tput sgr0;
            exit 1;
        fi;
        echo "$EXPORT_LIST_APPS" >> $TMPL_DIR/imagelist;

        echo "Creating '$1'";
        (cd $TMPL_DIR && tar cf archive.tar *)
        if [[ $? -ne 0 ]];then
            echo -e "\E[31mERROR: Cannot create archive '$TMPL_DIR/archive.tar'.">&2;tput sgr0;
            exit 1;
        fi;
        mv $TMPL_DIR/archive.tar "$1";
        if [[ $? -ne 0 ]];then
            echo -e "\E[31mERROR: Cannot create archive '$1'.">&2;tput sgr0;
            exit 1;
        fi;

        echo "Clear temp directories...";
        rm -rf $TMPL_DIR;
        if [[ $? -ne 0 ]];then
            echo -e "\E[31mERROR: Cannot remove '$TMPL_DIR'.">&2;tput sgr0;
            exit 1;
        fi;
    fi
    echo -e "\E[32mComplete. Export result is saved to '$1'.";tput sgr0;
}

import_func(){
    if ! [[ -f "$1" ]];then
        echo -e "\E[31mERROR: File '$1' not found.">&2;tput sgr0;
        exit 1;
    fi;

    # Is it file or archive?
    local TMPL_DIR=`mktemp -d`;
    tar xf $1 -C $TMPL_DIR/ > /dev/null 2>&1;
    if [[ $? -ne 0 ]];then
        cp -f $1 $TMPL_DIR/imagelist;
        local IMPORT_SOURCE="file";
    else
        local IMPORT_SOURCE="archive";
    fi;

    #Check OS
    local OS_NAME="`cat /etc/os-release | grep "PRETTY_NAME=" | awk -F '"' '{print $2}'`";
    if [[ -z "$OS_NAME" ]];then
        echo -e "\E[31mERROR: File '/etc/os-release' doesn't contain variable PRETTY_NAME.">&2;tput sgr0;
        exit 1;
    fi;
    local OS_EXPORT="`cat $TMPL_DIR/imagelist | head -1 | grep '^#.*#$' | awk -F '#' '{print $2}'`";
    if [[ -z "$OS_EXPORT" ]];then
        echo -e "\E[31mERROR: Invalid file format.">&2;tput sgr0;
        exit 1;
    fi;
    if [[ "$OS_NAME" != "$OS_EXPORT" ]];then
        echo -e -n "\n\E[33mWARN: Current vesrion OS: ";tput sgr0;
        echo "$OS_NAME";
        echo -e -n "\n\E[33mVesrion OS from export file: ";tput sgr0;
        echo "$OS_EXPORT";
        read -r -p "This OS versions can be incompatible. Continue the import? [y/N] " response
                    case $response in
                        [yY][eE][sS]|[yY])
                          echo
                          ;;
                        *)
                          rm -rf $TMPL_DIR;
                          exit 0
                          ;;
                    esac
    fi;

    #If achive - load apps
    if [[ $IMPORT_SOURCE == archive ]];then
        local IMPORT_FILE_NAME;
        for IMPORT_FILE_NAME in `ls -1 $TMPL_DIR | grep -v imagelist`
        do
            echo -e "\E[32mDocker load image from '$TMPL_DIR/$IMPORT_FILE_NAME'.\n";tput sgr0;
            docker load -i $TMPL_DIR/$IMPORT_FILE_NAME;
            if [[ $? -ne 0 ]];then
                 echo -e "\E[31mERROR: Cannot load '$TMPL_DIR/$IMPORT_FILE_NAME'. Import was aborted.">&2;tput sgr0;
                 exit 1;
            fi;
        done
    fi;

    echo -e "\E[32mCheck applications availability for installation.\n";tput sgr0;

    local PREFIX_IMAGE='smilart';
    local IMPORT_APP;
    local IMPORT_APP_NAME;
    local IMPORT_APP_VERSION;
    local IMPORT_APP_ID;

    # load apps from repo
    for IMPORT_APP in `cat $TMPL_DIR/imagelist | awk 'FNR>1' | awk -F '|' '{print $1 ":" $2}'`
    do
        IMPORT_APP_NAME="`echo $IMPORT_APP | awk -F ':' '{print $1}'`";
        IMPORT_APP_VERSION="`echo $IMPORT_APP | awk -F ':' '{print $2}'`";
        IMPORT_APP_ID=`docker images | grep -v 'REPOSITORY' | awk -F ' ' ' {print $1,$2,$3} ' | sed "s/ /:/g" | grep "$PREFIX_IMAGE/$IMPORT_APP_NAME:$IMPORT_APP_VERSION:" | awk -F ':' '{print $NF}'`;
        if [[ -z $IMPORT_APP_ID ]];then
             echo;
             pull_image_from_repo $IMPORT_APP_NAME $IMPORT_APP_VERSION;
             if [[ $? -ne 0 ]];then
                  echo -e "\E[31mERROR: Cannot pull '$IMPORT_APP_NAME:$IMPORT_APP_VERSION' from SAM default repository. Import was aborted.">&2;tput sgr0;
                  exit 1;
             fi;

             PREFIX_IMAGE=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where ReposFlag='*'"`;
             IMPORT_APP_ID=`docker images | grep -v 'REPOSITORY' | awk -F ' ' ' {print $1,$2,$3} ' | sed "s/ /:/g" | grep "$PREFIX_IMAGE/$IMPORT_APP_NAME:$IMPORT_APP_VERSION:" | awk -F ':' '{print $NF}'`;
             create_tag_app $IMPORT_APP_ID $IMPORT_APP_NAME:$IMPORT_APP_VERSION;
             if [[ -z $IMPORT_APP_ID ]];then
                 echo -e "\E[31mERROR: Docker image '$PREFIX_IMAGE/$IMPORT_APP_NAME:$IMPORT_APP_VERSION' not found.">&2;tput sgr0;
                 exit 1;
             fi;
             docker logout 2>&1 > /dev/null;
        fi;
    done;

    #Generate lists with changes
    #<name>:<version>
    local LIST_APPS_REMOVE="$TMPL_DIR/removelist";
    local APPS_REMOVE;
    #<name>:<version>
    local LIST_APPS_SKIP="$TMPL_DIR/skiplist";
    #<name>:<version>|<id>|<repo id>
    local LIST_APPS_ADD="$TMPL_DIR/addlist";

    for IMPORT_APP in `cat $TMPL_DIR/imagelist | awk 'FNR>1' | awk -F '|' '{print $1 ":" $2}'`
    do
        IMPORT_APP_NAME="`echo $IMPORT_APP | awk -F ':' '{print $1}'`";
        IMPORT_APP_VERSION="`echo $IMPORT_APP | awk -F ':' '{print $2}'`";
        IMPORT_APP_ID=`docker images | grep -v 'REPOSITORY' | awk -F ' ' ' {print $1,$2,$3} ' | sed "s/ /:/g" | grep "$PREFIX_IMAGE/$IMPORT_APP_NAME:$IMPORT_APP_VERSION:" | awk -F ':' '{print $NF}'`;
        IMPORT_APP_REPO_ID=`sqlite3 $SAM_DB_SQLITE "SELECT id from $SAM_DB_TABLE_REPOS where ReposFlag='*'"`;

        if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$IMPORT_APP_NAME' AND ImageVersion='$IMPORT_APP_VERSION'"` ]];then
            if [[ "$GETOPT_RESTORE" == "true" ]];then
                echo "$IMPORT_APP_NAME:$IMPORT_APP_VERSION|$IMPORT_APP_ID|$IMPORT_APP_REPO_ID" >> $LIST_APPS_ADD;
            else
                echo "$IMPORT_APP" >> $LIST_APPS_SKIP;
            fi;
            continue
        fi;
        if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ImageName from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$IMPORT_APP_NAME'"` ]]; then
                APPS_REMOVE=`sqlite3 $SAM_DB_SQLITE "SELECT ImageName, ImageVersion from $SAM_DB_TABLE_INSTALL_APPS where ImageName='$IMPORT_APP_NAME'" | awk -F '|' '{print $1 ":" $2}'`;
                echo "$APPS_REMOVE" >> $LIST_APPS_REMOVE;
        fi;
        echo "$IMPORT_APP_NAME:$IMPORT_APP_VERSION|$IMPORT_APP_ID|$IMPORT_APP_REPO_ID" >> $LIST_APPS_ADD;

    done;
    #If exist flug --restore then remove all apps
    if [[ "$GETOPT_RESTORE" == "true" ]];then
        APPS_REMOVE=`sqlite3 $SAM_DB_SQLITE "SELECT ImageName, ImageVersion from $SAM_DB_TABLE_INSTALL_APPS" | awk -F '|' '{print $1 ":" $2}'`
        if [[ -n $APPS_REMOVE ]];then
            echo "$APPS_REMOVE" > $LIST_APPS_REMOVE;
        fi;
    fi;

    #Print changes lists
    echo; 
    if [[ -f $LIST_APPS_SKIP ]];then 
        echo -e "List skipped applications:\E[33m";
        cat $LIST_APPS_SKIP;
        tput sgr0;
        echo;
    fi;
    if [[ -f $LIST_APPS_REMOVE ]];then
        echo -e "List removed applications:\E[31m";
        cat $LIST_APPS_REMOVE;
        tput sgr0;
        echo;
    fi;
    if [[ -f $LIST_APPS_ADD ]];then
        echo -e "List added applications:\E[32m";
        cat $LIST_APPS_ADD | awk -F '|' '{print $1}';
        tput sgr0;
        echo;
    fi;
    read -r -p "Continue the import? [y/N] " response
         case $response in
              [yY][eE][sS]|[yY])
                  echo
                  ;;
              *)
                  rm -rf $TMPL_DIR;
                  exit 0
              ;;
         esac
    
    #REMOVE apps
    if [[ -f $LIST_APPS_REMOVE ]];then
        echo -e "\E[32mRemoving applications from the system.\n";tput sgr0;
        for IMPORT_APP_REMOVE in `cat "$LIST_APPS_REMOVE"`    
        do
             remove_func "$IMPORT_APP_REMOVE";
        done;
    fi;

    #INSTALL apps
    if [[ -f $LIST_APPS_ADD ]];then
        echo -e "\E[32m\nInstalling applications from docker cache.\n";tput sgr0;
        for IMPORT_APP_ADD in `cat "$LIST_APPS_ADD"`    
        do
            IMPORT_APP_NAME="`echo $IMPORT_APP_ADD | awk -F '|' '{print $1}' | awk -F ':' '{print $1}'`";
            IMPORT_APP_VERSION="`echo $IMPORT_APP_ADD | awk -F '|' '{print $1}' | awk -F ':' '{print $2}'`";
            IMPORT_APP_ID="`echo $IMPORT_APP_ADD | awk -F '|' '{print $2}'`";
            IMPORT_APP_REPO_ID="`echo $IMPORT_APP_ADD | awk -F '|' '{print $3}'`";

            install_app_func $IMPORT_APP_ID;
            save_app_in_db $IMPORT_APP_ID $IMPORT_APP_NAME $IMPORT_APP_VERSION $IMPORT_APP_REPO_ID;
            if [[ $? -ne 0 ]]; then
                echo -e "\E[31mERROR: '$IMPORT_APP_ID $IMPORT_APP_NAME $IMPORT_APP_VERSION $IMPORT_APP_REPO_ID' was not saved in SAM database">&2;tput sgr0;
                exit 1;
            fi;
            echo;
        done;
    fi;

    echo "Clear temp directories";
    rm -rf $TMPL_DIR;
    if [[ $? -ne 0 ]];then
        echo -e "\E[31mERROR: Cannot remove '$TMPL_DIR'.">&2;tput sgr0;
        exit 1;
    fi;

    echo -e "\E[32m\nImport was completed successfully.";tput sgr0;

}

addrepo_func(){
    #It is correct name and url?
    if [[ -z $GETOPT_NAME ]] || [[ -z $GETOPT_SERVER ]];then
         echo "$USAGE_ADDREPO";
         echo -e "\E[31mERROR: Argument for 'sam addrepo' is not correct.">&2;tput sgr0;
         exit 1;
    fi;
    #Exist name in db?
    if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposName='$GETOPT_NAME'"` ]];then
         echo -e "\E[31mERROR: Repository name '$GETOPT_NAME' already exists in SAM database.">&2;tput sgr0;
         exit 1;
    fi;
    GETOPT_PASSWORD=`echo "$GETOPT_PASSWORD" | base64`;

    #save in db
    sqlite3 $SAM_DB_SQLITE "insert into $SAM_DB_TABLE_REPOS (ReposFlag,ReposName,ReposUrl,ReposUser,ReposPass) values ('$GETOPT_DEFAULT','$GETOPT_NAME','$GETOPT_SERVER','$GETOPT_USERNAME','$GETOPT_PASSWORD')";
    if [[ -n $GETOPT_DEFAULT ]];then
       sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposFlag=''";
       sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposFlag='*' where ReposName='$GETOPT_NAME'";
    fi;
}

removerepo_func(){
    # $1 is name or id repository
    #Found repo name in db?
    if [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposName='$1'"` ]];then
        #delete in db
        #Default repository?
        if [[ '*' == `sqlite3 $SAM_DB_SQLITE "select ReposFlag from $SAM_DB_TABLE_REPOS where ReposName='$1'"` ]]; then
                echo -e "\E[31mERROR: Repository '$1' is default.">&2;tput sgr0;
                exit 1;
        fi;
        sqlite3 $SAM_DB_SQLITE "delete from $SAM_DB_TABLE_REPOS where ReposName='$1'";

    #Found id in db?
    elif [[ -n `sqlite3 $SAM_DB_SQLITE "SELECT Id from $SAM_DB_TABLE_REPOS where Id='$1'"` ]];then
        #delete in db
        #Default repository?
        if [[ '*' == `sqlite3 $SAM_DB_SQLITE "select ReposFlag from $SAM_DB_TABLE_REPOS where Id='$1'"` ]]; then
                echo -e "\E[31mERROR: Repository number '$1' is default.">&2;tput sgr0;
                exit 1;
        fi;
        sqlite3 $SAM_DB_SQLITE "delete from $SAM_DB_TABLE_REPOS where Id='$1'";
    else
            echo -e "\E[31mERROR: Repository name or number '$1' not found in SAM database.">&2;tput sgr0;
            exit 1;
    fi;
}

modifyrepo_func(){
    #It is correct name and url?
    if [[ -z $1 ]];then
         echo "$USAGE_MODIFYREPO";
         echo -e "\E[31mERROR: Argument id repository for 'sam modifyrepo' is not correct.">&2;tput sgr0;
         exit 1;
    fi;
    if [[ -z `sqlite3 $SAM_DB_SQLITE "SELECT Id from $SAM_DB_TABLE_REPOS where Id='$1'"` ]];then
        echo -e "\E[31mERROR: Repository number '$1' not found in db.">&2;tput sgr0;
        exit 1;
    fi;
    GETOPT_NAME=`[[ -z $GETOPT_NAME ]] && sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where id='$1'" || echo $GETOPT_NAME`;
    GETOPT_SERVER=`[[ -z $GETOPT_SERVER ]] && sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where id='$1'" || echo $GETOPT_SERVER`;
    GETOPT_USERNAME=`[[ -z $GETOPT_USERNAME ]] && sqlite3 $SAM_DB_SQLITE "SELECT ReposUser from $SAM_DB_TABLE_REPOS where id='$1'" || echo $GETOPT_USERNAME`;
    GETOPT_PASSWORD=`[[ -z $GETOPT_PASSWORD ]] && sqlite3 $SAM_DB_SQLITE "SELECT ReposPass from $SAM_DB_TABLE_REPOS where id='$1'" || echo $GETOPT_PASSWORD | base64`;
    sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposName='$GETOPT_NAME',ReposUrl='$GETOPT_SERVER',ReposUser='$GETOPT_USERNAME',ReposPass='$GETOPT_PASSWORD' where id='$1'";
    if [[ $GETOPT_DEFAULT == '*' ]];then
        sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposFlag=''";
        sqlite3 $SAM_DB_SQLITE "update $SAM_DB_TABLE_REPOS SET ReposFlag='*' where id='$1'";
    fi;
}

listrepos_func(){

    local LIST_REPOSITORIES_MAX_LINE;
    local LIST_REPOSITORIES;

    if [ -z "$GETOPT_RAW" ];then
        echo;
        echo "      List repositories:";
        echo;
        LIST_REPOSITORIES=`sqlite3 -header $SAM_DB_SQLITE "SELECT id as Num, ReposFlag as Def, ReposName as Name, ReposUrl as Url, ReposUser as User FROM $SAM_DB_TABLE_REPOS" |  sed 's/|/#|  /g' | column -t -s '#'`;
        LIST_REPOSITORIES_MAX_LINE=`echo "$LIST_REPOSITORIES" | wc -L`;
        echo "$LIST_REPOSITORIES" | sed -e "1 a `for i in \`seq 1 $LIST_REPOSITORIES_MAX_LINE\`; do echo -n '-';  done`"
        echo;
    else
        sqlite3 $SAM_DB_SQLITE "SELECT id, ReposFlag, ReposName, ReposUrl, ReposUser FROM $SAM_DB_TABLE_REPOS";
    fi;
}

search_func(){

    local SAM_INSTALL_REPOS_NAME;
    local SAM_INSTALL_PASSWORD;
    local SAM_INSTALL_REPOS_URL;
    local SAM_INSTALL_USER;
    local CURRENT_VERSION;
    local CURRENT_IMAGE;
    local LIST_IMAGES;
    local FLUG_SHOW_VERSIONS;

    #Reade info from db
    SAM_INSTALL_REPOS_NAME=`sqlite3 $SAM_DB_SQLITE "SELECT ReposName from $SAM_DB_TABLE_REPOS where ReposFlag='*'" | sed 's/\/$//' | awk -F '/' '{print $NF}'`
    SAM_INSTALL_PASSWORD=`sqlite3 $SAM_DB_SQLITE "SELECT ReposPass from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'" | base64 -d`;
    SAM_INSTALL_REPOS_URL=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUrl from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'"`;
    #Get list images
    SAM_INSTALL_USER=`sqlite3 $SAM_DB_SQLITE "SELECT ReposUser from $SAM_DB_TABLE_REPOS where ReposName='$SAM_INSTALL_REPOS_NAME'" | sed 's/[\ \t]//g'`;
    if [ -n $SAM_INSTALL_USER ];then
        SAM_INSTALL_REPOS_URL=$SAM_INSTALL_USER:$SAM_INSTALL_PASSWORD@$SAM_INSTALL_REPOS_URL;
    fi;
    #Get version images to repository
    CURRENT_IMAGE='';
    CURRENT_VERSION='';
    echo > $SAM_HISTORY;
    echo;
    echo "      List image versions:";
    echo;

    LIST_IMAGES="`curl https://$SAM_INSTALL_REPOS_URL/v2/_catalog -s | awk -F '[' '{print $NF}' | awk -F ']' '{print $1}' | sed 's/,/,\n/g' | awk -F '"' '{print $2}'`"

    for CURRENT_IMAGE in `echo "$LIST_IMAGES"`
    do
        if [ -n "`echo \"$CURRENT_IMAGE\" | grep \"$1\"`" ];then
            FLUG_SHOW_VERSIONS=true
        else
            FLUG_SHOW_VERSIONS=false
        fi;

        if [[ ${FLUG_SHOW_VERSIONS} == true ]];then
            echo -n -e "\E[33m$CURRENT_IMAGE" | tr -d '\n' ; tput sgr0;
        fi;
        local sumb_brake=':'
        for CURRENT_VERSION in `curl https://$SAM_INSTALL_REPOS_URL/v2/$CURRENT_IMAGE/tags/list -s | awk -F '[' '{print $NF}' | awk -F ']' '{print $1}' | sed -E 's/\"//g;s/,/\n/g' | sort --version-sort -r`
        do
                if [[ ${FLUG_SHOW_VERSIONS} == true ]];then
                        echo -n -e "$sumb_brake$CURRENT_VERSION" | tr -d '\n';
                        sumb_brake=', '
                fi;

                echo "${CURRENT_IMAGE}:${CURRENT_VERSION}" >> $SAM_HISTORY
        done;

        if [[ ${FLUG_SHOW_VERSIONS} == true ]];then
            echo 
        fi;
    done;
}

purge_func(){
        local PURGE_LIST_APPS="`sqlite3 $SAM_DB_SQLITE \"SELECT DockerId FROM $SAM_DB_TABLE_INSTALL_APPS\"`"
        local CHECK_APP
        echo -e "Creating image checklist...\n"
        local CHECKLIST="`docker images -q`"
        echo -e "\nStarting garbage collection....\n";
        for CHECK_APP in `echo "$CHECKLIST"`
        do
            if [[ -z `echo "$PURGE_LIST_APPS" | grep "$CHECK_APP"` ]];then
                docker rmi -f "$CHECK_APP"
                echo
            fi
        done

        echo -e "\E[32mCarbage collection is completed.";tput sgr0;

}

help_func(){
    case $1 in
        install|in)
            echo "$USAGE_INSTALL";
            exit 0
            ;;
        remove|rm)
            echo "$USAGE_REMOVE";
            exit 0
            ;;
        list)
            echo "$USAGE_LIST";
            exit 0
            ;;
	purge)
            echo "$USAGE_PURGE";
            exit 0
            ;;
        info)
            echo "$USAGE_INFO";
            exit 0
            ;;
        addrepo|ar)
            echo "$USAGE_ADDREPO";
            exit 0
            ;;
        removerepo|rr)
            echo "$USAGE_REMOVEREPO";
            exit 0
            ;;
        modifyrepo|mr)
            echo "$USAGE_MODIFYREPO";
            exit 0
            ;;
        export|ex)
            echo "$USAGE_EXPORT";
            exit 0
            ;;
        import|im)
            echo "$USAGE_IMPORT";
            exit 0
            ;;
        listrepos|lr)
            echo "$USAGE_LISTREPOS";
            exit 0
            ;;
        search|se)
            echo "$USAGE_SEARCH";
            exit 0
            ;;
        *)
            echo "$USAGE";
            echo;
            ;;
    esac
}

###Case section
SAM_ARGUMENT=`getopt -o h:x --long help:,debug,raw,default,name:,server:,username:,password:,all,labels,restore --name "sam" -- "$@"`
eval set -- "$SAM_ARGUMENT";
unset SAM_ARGUMENT;
unset GETOPT_RAW;
unset GETOPT_DEFAULT;
unset GETOPT_NAME;
unset GETOPT_SERVER;
unset GETOPT_USERNAME;
unset GETOPT_PASSWORD;
unset GETOPT_ALL;
unset GETOPT_LABELS;
unset GETOPT_RESTORE;

while true ; do
    case "$1" in
        -h|--help)
            shift;
            help_func $@;
            exit 0
            ;;
        -x|--debug)
            set -vx;
            shift
            ;;
        --raw)
            GETOPT_RAW='*';
            shift
            ;;
        --default)
            GETOPT_DEFAULT='*';
            shift
            ;;
        --name)
            GETOPT_NAME=$2;
            shift 2
            ;;
        --server)
            GETOPT_SERVER=$2;
            shift 2
            ;;
        --username)
            GETOPT_USERNAME=$2;
            shift 2
            ;;
        --password)
            GETOPT_PASSWORD=$2;
            shift 2
            ;;
        --all)
            GETOPT_ALL='true';
            shift 
            ;;
        --labels)
            GETOPT_LABELS='true';
            shift
            ;;
        --restore)
            GETOPT_RESTORE='true';
            shift
            ;;
        --)
            shift;
            case "$1" in
                help)
                    shift;
                    help_func $@;
                    exit 0
                    ;;
                addrepo|ar)
                    shift;
                    addrepo_func;
                    exit 0
                    ;;
                listrepos|lr)
                    shift;
                    listrepos_func;
                    exit 0
                    ;;
                search|se)
                    shift;
                    search_func $1;
                    exit 0
                    ;;
                removerepo|rr)
                    shift;
                    removerepo_func $1;
                    exit 0
                    ;;
                modifyrepo|mr)
                    shift;
                    modifyrepo_func $1;
                    exit 0
                    ;;
                export|ex)
                    shift;
                    export_func $1;
                    exit 0
                    ;;
                import|im)
                    shift;
                    import_func $1;
                    exit 0
                    ;;
                list)
                    shift;
                    list_func;
                    exit 0
                    ;;
                purge)
                    shift;
                    purge_func;
                    exit 0
                    ;;
                install|in)
                    shift;
                    install_func $1;
                    exit 0
                    ;;
                remove|rm)
                    shift;
                    remove_func $1;
                    exit 0
                    ;;
                info)
                    shift;
                    info_func $1;
                    exit 0
                    ;;
            esac
            ;;
        *)
            echo "$USAGE";
            echo;
            exit 1
            ;;
    esac
done
